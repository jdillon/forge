#!/usr/bin/env bash
# bin/forge-dev - Development mode bootstrap
#
# Uses packaged tarball with isolated dev-home for development.
# Smart rebuild: only packs/installs when source files change.
# Avoids recursive directory hell by using tarball instead of directory reference.
#
# Usage:
#   ./bin/forge-dev [command] [args...]
#   FORGE_REBUILD=1 ./bin/forge-dev [command]  # Force rebuild
#
set -euo pipefail

#
# Globals
#

PROJECT_ROOT=""
FORGE_HOME=""

#
# Path resolution
#

resolve_paths() {
  # Resolve script location (follows symlinks)
  local script_path="${BASH_SOURCE[0]}"
  while [ -L "$script_path" ]; do
    local script_dir="$(cd -P "$(dirname "$script_path")" && pwd)"
    script_path="$(readlink "$script_path")"
    [[ $script_path != /* ]] && script_path="$script_dir/$script_path"
  done
  local script_dir="$(cd -P "$(dirname "$script_path")" && pwd)"

  PROJECT_ROOT="$(cd -P "${script_dir}/.." && pwd)"
  FORGE_HOME="${PROJECT_ROOT}/dev-home/forge"
}

setup_environment() {
  # Dev mode: use packaged tarball with isolated dev-home
  export FORGE_HOME
  export NODE_PATH="${FORGE_HOME}/node_modules"

  # Ensure dev-home forge structure exists
  mkdir -p "${FORGE_HOME}"
}

#
# Checksum-based change detection
#

compute_checksum() {
  (
    cd "${PROJECT_ROOT}"
    # Checksum lib/**, package.json, tsconfig.json, bunfig.toml
    (find lib -type f -exec sha256sum {} \; && \
    sha256sum package.json tsconfig.json bunfig.toml 2>/dev/null) | \
    sort | sha256sum | cut -d' ' -f1
  )
}

needs_rebuild() {
  local checksum_file="${FORGE_HOME}/.forge-checksum"
  local current=$(compute_checksum)
  local previous=$(cat "$checksum_file" 2>/dev/null || echo "")

  [[ "$current" != "$previous" ]]
}

save_checksum() {
  compute_checksum > "${FORGE_HOME}/.forge-checksum"
}

#
# Build steps
#

clear_bun_cache() {
  echo "  → Clearing Bun cache..." >&2
  bun pm cache rm >&2
}

build_tarball() {
  echo "  → Building tarball..." >&2
  local tarball="${PROJECT_ROOT}/build/planet57-forge-dev.tgz"

  # Clean old tarballs to avoid confusion
  rm -f "${tarball}"

  (
    cd "${PROJECT_ROOT}"
    bun pm pack --filename "${tarball}" >&2
  )

  if [[ ! -f "$tarball" ]]; then
    echo "ERROR: Expected tarball not found: $tarball" >&2
    exit 1
  fi

  # Return tarball path to caller (stdout only, all other output to stderr)
  echo "$tarball"
}

create_config_files() {
  local tarball="$1"

  # Create package.json with tarball reference
  cat > "${FORGE_HOME}/package.json" << EOF
{
  "name": "forge-dev-home",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@planet57/forge": "file:${tarball}"
  }
}
EOF

  # Create tsconfig.json (simulates what install.sh does) - only if it doesn't exist
  if [[ ! -f "${FORGE_HOME}/tsconfig.json" ]]; then
    cat > "${FORGE_HOME}/tsconfig.json" << 'EOF'
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@forge/*": ["./node_modules/@planet57/forge/lib/*"]
    }
  }
}
EOF
  fi

  # Create bunfig.toml (simulates what install.sh does) - only if it doesn't exist
  if [[ ! -f "${FORGE_HOME}/bunfig.toml" ]]; then
    cat > "${FORGE_HOME}/bunfig.toml" << 'EOF'
[install]
exact = true
dev = false
peer = true
optional = false
auto = "disable"
EOF
  fi
}

install_package() {
  echo "  → Installing to dev-home..." >&2

  # Purge old installed package to force fresh install
  rm -rf "${FORGE_HOME}/node_modules/@planet57/forge"

  (
    cd "${FORGE_HOME}"
    bun install
  )
}

generate_version_info() {
  echo "  → Generating version info..." >&2

  local pkg_dir="${FORGE_HOME}/node_modules/@planet57/forge"
  local version=$(node -p "require('${pkg_dir}/package.json').version" 2>/dev/null || echo "dev")

  # Get git info from project root (not the installed package)
  local hash=$(cd "${PROJECT_ROOT}" && git rev-parse --short HEAD 2>/dev/null || echo "dev")
  local hash_full=$(cd "${PROJECT_ROOT}" && git rev-parse HEAD 2>/dev/null || echo "dev")
  local timestamp=$(cd "${PROJECT_ROOT}" && git log -1 --format=%cI HEAD 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")
  local timestamp_unix=$(cd "${PROJECT_ROOT}" && git log -1 --format=%ct HEAD 2>/dev/null || date +%s)
  local branch=$(cd "${PROJECT_ROOT}" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "dev")
  local dirty=$(cd "${PROJECT_ROOT}" && git diff-index --quiet HEAD 2>/dev/null && echo "false" || echo "true")

  # Extract date and time components (YYYYMMDD.HHMM) from timestamp
  # Timestamp format: 2025-11-09T21:28:47Z or 2025-11-09T12:49:29-08:00
  local date_part=$(echo "$timestamp" | cut -d'T' -f1 | tr -d '-')  # 20251109
  local time_part=$(echo "$timestamp" | cut -d'T' -f2 | cut -d':' -f1,2 | tr -d ':')  # 2128
  local date_time="${date_part}.${time_part}"

  # Build semver
  local semver="${version}+${date_time}.${hash}"

  # Write version.json to forge home
  cat > "${FORGE_HOME}/version.json" <<EOF
{
  "version": "$version",
  "hash": "$hash",
  "hashFull": "$hash_full",
  "timestamp": "$timestamp",
  "timestampUnix": $timestamp_unix,
  "branch": "$branch",
  "dirty": $dirty,
  "semver": "$semver"
}
EOF
}

rebuild_and_install() {
  echo "" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
  echo "  Rebuilding forge (source files changed)" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2

  clear_bun_cache
  local tarball=$(build_tarball)
  create_config_files "$tarball"
  install_package
  generate_version_info
  save_checksum

  echo "  ✓ Rebuild complete" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
  echo "" >&2
}

#
# Forge execution
#

run_forge() {
  local is_restarted="$1"
  shift

  # Set restart flag if this is a restart
  if [[ "$is_restarted" == "true" ]]; then
    export FORGE_RESTARTED=1
  fi

  # Find the CLI entry point in installed package
  local cli_path="${FORGE_HOME}/node_modules/@planet57/forge/lib/cli.ts"

  if [[ ! -f "$cli_path" ]]; then
    echo "ERROR: CLI not found at $cli_path" >&2
    exit 1
  fi

  # Use --preserve-symlinks to prevent Bun from resolving through symlinks
  # This allows user commands symlinked into node_modules to resolve forge correctly
  bun run --preserve-symlinks "${cli_path}" "$@"
}

handle_restart() {
  local exit_code="$1"
  shift

  # Exit code 42 = restart needed (dependencies installed)
  # "I checked it very thoroughly, and that quite definitely is the answer."
  if [[ $exit_code -eq 42 ]]; then
    # Re-run with FORGE_RESTARTED=1 to prevent infinite loops
    run_forge "true" "$@"
    return $?
  fi

  return "$exit_code"
}

#
# Main
#

main() {
  # Initialize paths and environment
  resolve_paths
  setup_environment

  # Check if rebuild needed (or forced via FORGE_REBUILD=1)
  if [[ "${FORGE_REBUILD:-}" == "1" ]] || needs_rebuild; then
    rebuild_and_install
  fi

  # Run forge and handle restart if needed
  set +e  # Don't exit on non-zero
  run_forge "false" "$@"
  local exit_code=$?
  set -e

  handle_restart "$exit_code" "$@"
}

# Execute main with all arguments
main "$@"
