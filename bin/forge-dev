#!/usr/bin/env bash
# Copyright 2025 Jason Dillon
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# bin/forge-dev - Development mode bootstrap
#
# Uses packaged tarball with isolated dev-home for development.
# Smart rebuild: only packs/installs when source files change.
# Avoids recursive directory hell by using tarball instead of directory reference.
#
# Usage:
#   ./bin/forge-dev [command] [args...]
#   FORGE_REBUILD=1 ./bin/forge-dev [command]  # Force rebuild
#
set -euo pipefail

#
# Globals
#

PROJECT_ROOT=""
# FORGE_HOME set in setup_environment() to dev-home/forge

#
# Path resolution
#

resolve_paths() {
  # Resolve script location (follows symlinks)
  local script_path="${BASH_SOURCE[0]}"
  while [ -L "$script_path" ]; do
    local script_dir="$(cd -P "$(dirname "$script_path")" && pwd)"
    script_path="$(readlink "$script_path")"
    [[ $script_path != /* ]] && script_path="$script_dir/$script_path"
  done
  local script_dir="$(cd -P "$(dirname "$script_path")" && pwd)"

  PROJECT_ROOT="$(cd -P "${script_dir}/.." && pwd)"
  FORGE_HOME="${PROJECT_ROOT}/dev-home/forge"
}

setup_environment() {
  # Dev mode: use packaged tarball with isolated dev-home
  export FORGE_HOME
  export NODE_PATH="${FORGE_HOME}/node_modules"

  # Ensure dev-home forge structure exists
  mkdir -p "${FORGE_HOME}"
}

#
# Checksum-based change detection
#

compute_checksum() {
  (
    cd "${PROJECT_ROOT}"
    # Checksum lib/**, package.json, tsconfig.json, bunfig.toml
    (find lib -type f -exec sha256sum {} \; && \
    sha256sum package.json tsconfig.json bunfig.toml 2>/dev/null) | \
    sort | sha256sum | cut -d' ' -f1
  )
}

needs_rebuild() {
  local checksum_file="${FORGE_HOME}/.forge-checksum"
  local current=$(compute_checksum)
  local previous=$(cat "$checksum_file" 2>/dev/null || echo "")

  [[ "$current" != "$previous" ]]
}

save_checksum() {
  compute_checksum > "${FORGE_HOME}/.forge-checksum"
}

#
# Build steps
#

clear_bun_cache() {
  echo "  → Clearing Bun cache..." >&2
  bun pm cache rm >&2
}

build_tarball() {
  echo "  → Building tarball..." >&2
  local tarball="${PROJECT_ROOT}/build/planet57-forge-dev.tgz"

  # Clean old tarballs to avoid confusion
  rm -f "${tarball}"

  (
    cd "${PROJECT_ROOT}"
    bun pm pack --filename "${tarball}" >&2
  )

  if [[ ! -f "$tarball" ]]; then
    echo "ERROR: Expected tarball not found: $tarball" >&2
    exit 1
  fi

  # Return tarball path to caller (stdout only, all other output to stderr)
  echo "$tarball"
}

create_config_files() {
  local tarball="$1"

  # Create package.json with tarball reference
  cat > "${FORGE_HOME}/package.json" << EOF
{
  "name": "forge-dev-home",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@planet57/forge": "file:${tarball}"
  }
}
EOF

  # Create tsconfig.json (simulates what install.sh does) - only if it doesn't exist
  if [[ ! -f "${FORGE_HOME}/tsconfig.json" ]]; then
    cat > "${FORGE_HOME}/tsconfig.json" << 'EOF'
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@forge/*": ["./node_modules/@planet57/forge/lib/*"]
    }
  }
}
EOF
  fi

  # Create bunfig.toml (simulates what install.sh does) - only if it doesn't exist
  if [[ ! -f "${FORGE_HOME}/bunfig.toml" ]]; then
    cat > "${FORGE_HOME}/bunfig.toml" << 'EOF'
[install]
exact = true
dev = false
peer = true
optional = false
auto = "disable"
EOF
  fi
}

install_package() {
  echo "  → Installing to dev-home..." >&2

  # Purge old installed package to force fresh install
  rm -rf "${FORGE_HOME}/node_modules/@planet57/forge"

  (
    cd "${FORGE_HOME}"
    bun install
  )
}

generate_version_info() {
  echo "  → Generating version info..." >&2

  local pkg_dir="${FORGE_HOME}/node_modules/@planet57/forge"
  local version=$(node -p "require('${pkg_dir}/package.json').version" 2>/dev/null || echo "dev")

  # Get git info from project root (not the installed package)
  local hash=$(cd "${PROJECT_ROOT}" && git rev-parse --short HEAD 2>/dev/null || echo "dev")
  local hash_full=$(cd "${PROJECT_ROOT}" && git rev-parse HEAD 2>/dev/null || echo "dev")
  local timestamp=$(cd "${PROJECT_ROOT}" && git log -1 --format=%cI HEAD 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")
  local timestamp_unix=$(cd "${PROJECT_ROOT}" && git log -1 --format=%ct HEAD 2>/dev/null || date +%s)
  local branch=$(cd "${PROJECT_ROOT}" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "dev")
  local dirty=$(cd "${PROJECT_ROOT}" && git diff-index --quiet HEAD 2>/dev/null && echo "false" || echo "true")

  # Extract date and time components (YYYYMMDD.HHMM) from timestamp
  # Timestamp format: 2025-11-09T21:28:47Z or 2025-11-09T12:49:29-08:00
  local date_part=$(echo "$timestamp" | cut -d'T' -f1 | tr -d '-')  # 20251109
  local time_part=$(echo "$timestamp" | cut -d'T' -f2 | cut -d':' -f1,2 | tr -d ':')  # 2128
  local date_time="${date_part}.${time_part}"

  # Build semver
  local semver="${version}+${date_time}.${hash}"

  # Write version.json to forge home
  cat > "${FORGE_HOME}/version.json" <<EOF
{
  "version": "$version",
  "hash": "$hash",
  "hashFull": "$hash_full",
  "timestamp": "$timestamp",
  "timestampUnix": $timestamp_unix,
  "branch": "$branch",
  "dirty": $dirty,
  "semver": "$semver"
}
EOF
}

rebuild_and_install() {
  echo "" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
  echo "  Rebuilding forge (source files changed)" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2

  clear_bun_cache
  local tarball=$(build_tarball)
  create_config_files "$tarball"
  install_package
  generate_version_info
  save_checksum

  echo "  ✓ Rebuild complete" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
  echo "" >&2
}

#
# Delegate to bin/forge
#

run_forge() {
  # Delegate to bin/forge script (installed mode bootstrap)
  # It will use our FORGE_HOME environment variable
  exec "${PROJECT_ROOT}/bin/forge" "$@"
}

#
# Main
#

main() {
  # Initialize paths and environment
  resolve_paths
  setup_environment

  # Check if rebuild needed (or forced via FORGE_REBUILD=1)
  if [[ "${FORGE_REBUILD:-}" == "1" ]] || needs_rebuild; then
    rebuild_and_install
  fi

  # Delegate to bin/forge (will exec, replacing this process)
  # bin/forge handles restart logic (exit code 42)
  run_forge "$@"
}

# Execute main with all arguments
main "$@"
