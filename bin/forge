#!/usr/bin/env bash
# Copyright 2025 Jason Dillon
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IMPORANT: retain compatibility with bash v3 (macOS)
set -euo pipefail

#
# Globals
#

SCRIPT_DIR=""
FORGE_CLI=""
# FORGE_HOME is set via environment or defaulted in setup_environment()

#
# Path resolution
#

resolve_paths() {
  # Resolve symlinks to get actual script location
  local script_path="${BASH_SOURCE[0]}"
  while [[ -L "${script_path}" ]]; do
    local script_dir="$(cd "$(dirname "${script_path}")" && pwd)"
    script_path="$(readlink "${script_path}")"
    # Handle relative symlinks
    [[ "${script_path}" != /* ]] && script_path="${script_dir}/${script_path}"
  done

  # Installed mode only - forge-dev handles dev mode
  SCRIPT_DIR="$(cd "$(dirname "${script_path}")" && pwd)"
}

#
# Homebrew detection
#

detect_homebrew_install() {
  # Check if we're running from a Homebrew Cellar path
  # Pattern: /opt/homebrew/Cellar/forge/<version>/libexec/bin
  # or: /usr/local/Cellar/forge/<version>/libexec/bin (Intel Mac)
  if [[ "${SCRIPT_DIR}" == */Cellar/forge/*/libexec/bin ]]; then
    # Return libexec path (parent of bin)
    echo "${SCRIPT_DIR%/bin}"
    return 0
  fi
  return 1
}

run_homebrew_bootstrap() {
  local libexec="$1"
  local bootstrap_script="${SCRIPT_DIR}/brew-bootstrap.sh"

  if [[ ! -f "${bootstrap_script}" ]]; then
    echo "ERROR: Homebrew bootstrap script not found at ${bootstrap_script}" >&2
    exit 1
  fi

  "${bootstrap_script}" "${libexec}"
}

setup_environment() {
  # Set FORGE_HOME if not already set (e.g., by tests)
  if [[ -z "${FORGE_HOME:-}" ]]; then
    FORGE_HOME="${HOME}/.forge"
  fi
  export FORGE_HOME

  # Set up paths
  local node_modules="${FORGE_HOME}/node_modules"
  FORGE_CLI="${node_modules}/@planet57/forge/lib/cli.ts"

  # Set NODE_PATH for Bun's runtime module resolution
  # export NODE_PATH="${node_modules}"
}

validate_installation() {
  if [[ ! -f "${FORGE_CLI}" ]]; then
    local libexec
    if libexec=$(detect_homebrew_install); then
      # Homebrew install detected, run bootstrap
      run_homebrew_bootstrap "${libexec}"
      # Verify bootstrap succeeded
      if [[ ! -f "${FORGE_CLI}" ]]; then
        echo "ERROR: Homebrew bootstrap failed - forge CLI not found" >&2
        exit 1
      fi
    else
      echo "ERROR: Forge installation is corrupted" >&2
      echo "Expected: ${FORGE_CLI}" >&2
      exit 1
    fi
  fi
}

#
# Forge execution
#

run_forge() {
  local is_restarted="$1"
  shift

  # Set restart flag if this is a restart
  if [[ "$is_restarted" == "true" ]]; then
    export FORGE_RESTARTED=1
  fi

  # Use --preserve-symlinks to prevent Bun from resolving through symlinks
  # This allows user commands symlinked into node_modules to resolve forge correctly
  bun run --preserve-symlinks "${FORGE_CLI}" "$@"
}

handle_restart() {
  local exit_code="$1"
  shift

  # Exit code 42 = restart needed (dependencies installed)
  # "I checked it very thoroughly, and that quite definitely is the answer."
  if [[ $exit_code -eq 42 ]]; then
    # Re-run with FORGE_RESTARTED=1 to prevent infinite loops
    run_forge "true" "$@"
    return $?
  fi

  return "$exit_code"
}

#
# Main
#

main() {
  # Initialize paths and environment
  resolve_paths
  setup_environment
  validate_installation

  # Run forge and handle restart if needed
  set +e  # Don't exit on non-zero
  run_forge "false" "$@"
  local exit_code=$?
  set -e

  handle_restart "$exit_code" "$@"
}

# Execute main with all arguments
main "$@"
