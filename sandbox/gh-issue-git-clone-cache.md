# Git Dependencies via Clone-to-Cache + Import Maps

## Problem

Forge cannot currently use git repositories as module dependencies due to module resolution conflicts. When test fixtures import `@planet57/forge/*`, Bun's package self-reference resolves to local source instead of the installed/cached version, breaking singleton patterns (e.g., duplicate logger instances).

**Example of the problem:**
```typescript
// Inside tests/fixtures/example/.forge2/modules/test.ts
import { log } from '@planet57/forge/lib/logging';
// ❌ Resolves to local source, not installed package
// ❌ Creates separate logger instance from test environment
// ❌ Breaks singleton pattern
```

This blocks Phase 3 of the module system (git module loading) and prevents users from:
- Using private git repos as module sources
- Sharing modules without publishing to npm
- Using SSH keys for private repo access

## Proposed Solution

**Implement git clone to cache + import maps pattern** (proven by Cargo, Go modules, npm).

### How It Works

1. **User declares git dependencies** in `.forge2/config.yml`:
   ```yaml
   dependencies:
     - git+ssh://git@github.com/jdillon/forge-standard.git
     - git+ssh://git@github.com/jdillon/forge-common.git#v1.2.3
   ```

2. **`forge install` clones to cache**:
   ```
   ~/.local/share/forge/repos/
     github.com/jdillon/forge-standard/  ← git clone here
     github.com/jdillon/forge-common/
   ```

3. **Generate import map configuration** pointing to cache locations:
   - **Bun:** `tsconfig.json` paths
   - **Deno:** `deno.json` imports

4. **Runtime resolves via import map** → no self-reference, uses cached clone

### Benefits

✅ **SSH git support** - Uses existing SSH keys (no HTTPS tokens!)
✅ **Module resolution control** - Import maps override self-reference
✅ **Works with Bun or Deno** - Both support import map equivalents
✅ **Proven pattern** - Cargo, Go modules, npm all work this way
✅ **Offline support** - Works offline after initial clone
✅ **Full git features** - Branches, tags, commits, submodules

## Implementation Options

### Option A: Bun + tsconfig.json paths (Recommended for MVP)

**Why:** No migration needed, works today.

**Configuration:**
```json
// .forge2/tsconfig.json (generated by forge install)
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@jdillon/forge-standard/*": [
        "~/.local/share/forge/repos/github.com/jdillon/forge-standard/*"
      ]
    }
  }
}
```

**Status:** ✅ Tested and working (see experiments)

**Trade-offs:**
- ✅ No migration overhead
- ✅ Bun natively supports tsconfig paths at runtime
- ⚠️ TypeScript-specific (but we're already using TS)

**Reference:** `sandbox/experiments/bun-tsconfig-paths/findings.md`

### Option B: Deno + import maps (Future consideration)

**Why:** Native import maps, mature runtime, good security model.

**Configuration:**
```json
// deno.json (generated by forge install)
{
  "imports": {
    "@jdillon/forge-standard/": "~/.local/share/forge/repos/github.com/jdillon/forge-standard/"
  }
}
```

**Status:** ✅ Tested and working (see experiments)

**Trade-offs:**
- ✅ Import maps are a web standard
- ✅ Native TypeScript support
- ⚠️ Requires 3-4 day API migration (Bun → Deno APIs)
- ⚠️ One extra import line for shell scripting (dax)

**Reference:** `sandbox/experiments/deno-prototype/findings.md`, `sandbox/experiments/deno-prototype/cache-design.md`

### Option C: Support both runtimes

Git clone cache works identically for both. Different import map generation:
- Bun projects: generate `tsconfig.json`
- Deno projects: generate `deno.json`
- Share cache directory: `~/.local/share/forge/repos/`

## Implementation Plan

### Phase 1: Git Clone to Cache (1-2 days)

**Goals:**
- Parse git URLs from dependencies
- Clone repos to `~/.local/share/forge/repos/<host>/<org>/<repo>/`
- Track cloned repos in `~/.local/share/forge/cache-state.json`
- Support URL formats:
  - `git+ssh://git@github.com/org/repo.git`
  - `https://github.com/org/repo.git`
  - `org/repo` (GitHub shorthand)
  - With refs: `repo#branch`, `repo#v1.2.3`, `repo#commit-hash`

**Tasks:**
- [ ] URL parser for git dependencies
- [ ] Cache directory structure
- [ ] Git clone logic (check if exists → fetch/pull, else clone)
- [ ] Cache state tracking (JSON file with repo metadata)
- [ ] Support checkout of specific refs (branches, tags, commits)

**Code location:** `lib/dependencies/git.ts` (new)

### Phase 2: Import Map Generation (1 day)

**Goals:**
- Generate import map configuration from installed dependencies
- Support tsconfig.json (Bun) initially
- Make extensible for deno.json later

**Tasks:**
- [ ] Detect package name from cloned repo (package.json or heuristic)
- [ ] Generate tsconfig.json with paths pointing to cache
- [ ] Handle existing tsconfig (extend or merge)
- [ ] Update on `forge install`

**Code location:** `lib/dependencies/import-maps.ts` (new)

### Phase 3: Cache Management Commands (1 day)

**Goals:**
- Visibility into cache state
- Cleanup and maintenance

**Tasks:**
- [ ] `forge cache status` - List cached repos, refs, disk usage
- [ ] `forge cache clean [repo]` - Remove cached repos
- [ ] `forge cache update [repo]` - Fetch and update cached repos
- [ ] Cache statistics (disk usage, last updated, etc.)

**Code location:** `lib/commands/cache.ts` (new)

### Phase 4: Integration & Testing (1 day)

**Goals:**
- Integrate with existing `forge install` flow
- Test with real git repos
- Verify module resolution works

**Tasks:**
- [ ] Update `forge install` to handle git dependencies
- [ ] Test with forge-standard repo (create test repo if needed)
- [ ] Test module imports resolve to cache
- [ ] Test singleton preservation
- [ ] Update documentation

**Testing:**
- Use `examples/standard/` with git dependency
- Create test fixture that imports from git module
- Verify logger singleton not duplicated

### Total: 4-5 days

## Acceptance Criteria

- [ ] Can declare git dependencies in `.forge2/config.yml`
- [ ] `forge install` clones git repos to cache
- [ ] Import map configuration generated automatically
- [ ] Modules resolve from cache (not local source or self-reference)
- [ ] Singleton pattern preserved (e.g., single logger instance)
- [ ] Works with SSH git URLs (no token configuration required)
- [ ] Can specify branch/tag/commit refs
- [ ] Cache commands work (`status`, `clean`, `update`)
- [ ] Tests pass with git dependencies

## Technical Details

### Cache Directory Structure

```
~/.local/share/forge/
├── repos/                          # Git repository cache
│   ├── github.com/
│   │   ├── jdillon/
│   │   │   └── forge-standard/     # Cloned repo
│   │   │       ├── .git/
│   │   │       ├── commands/
│   │   │       └── lib/
│   │   └── other-user/
│   │       └── other-repo/
│   └── gitlab.com/
│       └── org/
│           └── private-repo/
├── cache-state.json                # Tracks cached repos
└── node_modules/                   # npm packages (existing)
```

### Cache State Format

```json
{
  "repos": {
    "github.com/jdillon/forge-standard": {
      "url": "git+ssh://git@github.com/jdillon/forge-standard.git",
      "ref": "main",
      "commit": "abc123...",
      "lastUpdated": "2025-11-03T10:00:00Z",
      "path": "~/.local/share/forge/repos/github.com/jdillon/forge-standard"
    }
  }
}
```

### Example User Workflow

```bash
# 1. Add git dependency
cat >> .forge2/config.yml <<EOF
dependencies:
  - git+ssh://git@github.com/jdillon/forge-standard.git
EOF

# 2. Install dependencies
forge install
# Cloning git+ssh://git@github.com/jdillon/forge-standard.git...
# Generating import map...
# Done!

# 3. Use in module
cat > .forge2/modules/hello.ts <<EOF
import { greet } from '@jdillon/forge-standard/lib/greet';
export const hello = {
  execute: () => greet('World')
};
EOF

# 4. Works!
forge hello
# Hello, World!

# 5. Cache management
forge cache status
# github.com/jdillon/forge-standard
#   Ref: main (abc123...)
#   Size: 1.2 MB
```

## Research & Experiments

All experiments are documented in `sandbox/experiments/`:

### Bun Plugin Investigation
- **Location:** `sandbox/experiments/test-plugin/`
- **Result:** ❌ Runtime plugins cannot intercept module imports
- **Details:** `sandbox/experiments/test-plugin/findings.md`
- **Time saved:** Stopped after 2 hours, avoided 8-12 hours of futile work

### Deno Evaluation
- **Location:** `sandbox/experiments/deno-prototype/`
- **Results:**
  - ✅ Import maps solve module resolution
  - ✅ Shell scripting DX equivalent (dax)
  - ✅ APIs have clear equivalents
  - ⚠️ Git HTTPS requires tokens (but clone cache solves this!)
- **Details:**
  - `sandbox/experiments/deno-prototype/findings.md` - Complete evaluation
  - `sandbox/experiments/deno-prototype/cache-design.md` - Git clone cache design
  - `sandbox/experiments/deno-prototype/test-*.ts` - Working tests
- **Conclusion:** Viable option for future sprint

### Bun tsconfig.json Paths
- **Location:** `sandbox/experiments/bun-tsconfig-paths/`
- **Result:** ✅ Works perfectly, same capability as import maps
- **Details:** `sandbox/experiments/bun-tsconfig-paths/findings.md`
- **Test:** Working example proves module resolution control
- **Conclusion:** Recommended for MVP

## Related Issues

- Blocks: Phase 3 (Git Module Loading) of module system
- Related to: Test fixture isolation
- Enables: Private git repo modules, SSH-based access

## References

### Internal Documentation
- Module resolution problem: `sandbox/bun-resolution-problem.md`
- Bun tsconfig paths: `sandbox/experiments/bun-tsconfig-paths/findings.md`
- Deno evaluation: `sandbox/experiments/deno-prototype/findings.md`
- Cache design: `sandbox/experiments/deno-prototype/cache-design.md`
- Plugin investigation: `sandbox/experiments/test-plugin/findings.md`

### External Documentation
- Bun tsconfig paths: https://bun.sh/docs/runtime/typescript
- Deno import maps: https://docs.deno.com/runtime/fundamentals/configuration/
- Import Maps spec: https://github.com/WICG/import-maps
- Cargo git dependencies: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories

## Open Questions

1. **Package name detection:** How to determine package name from git repo?
   - Option A: Read from package.json `name` field
   - Option B: Use repo path (org/repo → @org/repo)
   - Option C: Allow explicit mapping in config

2. **Version conflicts:** How to handle different projects needing different versions?
   - Option A: Per-project cache (like node_modules)
   - Option B: Global cache with version dirs (like Cargo)
   - **Recommendation:** Start with per-project for simplicity

3. **Update strategy:** When should repos update?
   - Option A: Explicit only (`forge cache update`)
   - Option B: Check on every install
   - **Recommendation:** Explicit for predictability

4. **Monorepo support:** How to handle repos with multiple packages?
   - Map entire repo, let user import subpaths
   - Example: `@org/monorepo/packages/module-a`

## Future Enhancements

- [ ] Parallel cloning (multiple git deps)
- [ ] Shallow clones (--depth 1) for faster installs
- [ ] Submodule support
- [ ] GitLab, Bitbucket support (currently GitHub-focused)
- [ ] Cache size limits and automatic cleanup
- [ ] Lock file for reproducible installs
- [ ] Deno runtime support (generate deno.json instead)

## Migration Path (if choosing Deno later)

If we decide to sprint on Deno:

1. Git clone cache logic is **identical** (already runtime-agnostic)
2. Only change: Generate `deno.json` instead of `tsconfig.json`
3. API migration: ~3-4 days for Bun → Deno APIs
4. Can compare performance and DX with working baseline

This gives us flexibility to evaluate Deno later without blocking current progress.

---

**Labels:** `enhancement`, `module-system`, `phase-3`
**Milestone:** Module System Phase 3 - Git Dependencies
**Estimate:** 4-5 days
